"""
Integrated Penetration Testing Platform
=======================================

Comprehensive integration platform that combines all penetration testing
components with existing security infrastructure to provide a unified,
enterprise-grade security testing solution.

Key Features:
- Unified API for all penetration testing operations
- Integration with existing security monitoring and audit systems
- Multi-classification support and compliance frameworks
- Automated workflow orchestration
- Real-time security monitoring and alerting
- Comprehensive reporting and analytics

Classification: UNCLASSIFIED//FOR OFFICIAL USE ONLY
Version: 1.0 - Integrated Platform
Author: Security Testing Team
Date: 2025-07-28
"""

import asyncio
import json
import logging
import time
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Any, Tuple, Set, Union
from uuid import UUID, uuid4
from dataclasses import dataclass, field, asdict
from enum import Enum
from collections import defaultdict
from pathlib import Path

# Import all penetration testing components
try:
    from .environment.isolated_test_environment import (
        IsolatedTestEnvironment, SecurityLevel, NetworkIsolationType, ResourceLimits
    )
    from .infrastructure.testing_infrastructure import (
        TestingInfrastructure, InfrastructureType, TargetSystemConfig
    )
    from .isolation.security_isolation_framework import (
        SecurityIsolationFramework, IsolationLevel, ThreatLevel
    )
    from .orchestration.environment_orchestrator import (
        EnvironmentOrchestrator, TestScenario, OrchestrationStatus
    )
    PENTEST_COMPONENTS_AVAILABLE = True
except ImportError:
    PENTEST_COMPONENTS_AVAILABLE = False

# Import existing security infrastructure
try:
    from ..monitoring.cac_piv_security_monitor import CACPIVSecurityMonitor
    from ..audits.audit_logger import AuditLogger
    from ..audits.real_time_alerting import RealTimeAlerting
    from ..multi_classification.enhanced_classification_engine import EnhancedClassificationEngine
    from ..security_testing.penetration_testing_framework import PenetrationTestingFramework
    SECURITY_INFRASTRUCTURE_AVAILABLE = True
except ImportError:
    SECURITY_INFRASTRUCTURE_AVAILABLE = False

logger = logging.getLogger(__name__)

class PlatformStatus(Enum):
    """Platform operational status"""
    INITIALIZING = "initializing"
    READY = "ready"
    DEGRADED = "degraded"
    MAINTENANCE = "maintenance"
    ERROR = "error"

class TestingMode(Enum):
    """Testing operational modes"""
    DEVELOPMENT = "development"
    TESTING = "testing"
    PRODUCTION = "production"
    COMPLIANCE = "compliance"

@dataclass
class PlatformConfiguration:
    """Platform configuration settings"""
    testing_mode: TestingMode = TestingMode.TESTING
    max_concurrent_environments: int = 10
    max_concurrent_workflows: int = 5
    default_environment_duration_hours: int = 8
    auto_cleanup_enabled: bool = True
    compliance_mode_enabled: bool = True
    real_time_monitoring_enabled: bool = True
    classification_enforcement_enabled: bool = True
    audit_all_activities: bool = True
    notification_channels: List[str] = field(default_factory=lambda: ["email", "siem"])
    resource_monitoring_interval: int = 60
    security_scan_interval: int = 300

@dataclass
class PlatformMetrics:
    """Platform operational metrics"""
    total_environments_created: int = 0
    active_environments: int = 0
    total_workflows_executed: int = 0
    active_workflows: int = 0
    security_violations_detected: int = 0
    environments_quarantined: int = 0
    average_environment_duration_minutes: float = 0.0
    resource_utilization_percent: float = 0.0
    uptime_hours: float = 0.0
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

class IntegratedPentestPlatform:
    """
    Main platform class that integrates all penetration testing components
    with existing security infrastructure to provide a unified testing solution.
    
    This platform provides enterprise-grade penetration testing capabilities
    with comprehensive security controls, monitoring, and compliance features.
    """
    
    def __init__(self, 
                 configuration: Optional[PlatformConfiguration] = None,
                 existing_audit_logger: Optional[Any] = None,
                 existing_monitoring_system: Optional[Any] = None,
                 existing_classification_engine: Optional[Any] = None,
                 existing_alerting_system: Optional[Any] = None):
        """
        Initialize integrated penetration testing platform.
        
        Args:
            configuration: Platform configuration settings
            existing_audit_logger: Existing audit logging system
            existing_monitoring_system: Existing security monitoring system
            existing_classification_engine: Existing classification engine
            existing_alerting_system: Existing alerting system
        """
        self.config = configuration or PlatformConfiguration()
        self.status = PlatformStatus.INITIALIZING
        self.start_time = datetime.now(timezone.utc)
        
        # Use existing infrastructure or create new instances
        self.audit_logger = existing_audit_logger
        self.monitoring_system = existing_monitoring_system
        self.classification_engine = existing_classification_engine
        self.alerting_system = existing_alerting_system
        
        # Initialize penetration testing components
        self.environment_manager = None
        self.infrastructure_manager = None
        self.isolation_framework = None
        self.orchestrator = None
        
        # Platform state
        self.metrics = PlatformMetrics()
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
        self.security_events: List[Dict[str, Any]] = []
        
        # Initialize components
        asyncio.create_task(self._initialize_platform())
        
        logger.info("Integrated Penetration Testing Platform initializing")

    async def _initialize_platform(self) -> None:
        """Initialize all platform components"""
        try:
            # Initialize core penetration testing components
            self.environment_manager = IsolatedTestEnvironment(
                audit_logger=self.audit_logger,
                monitoring_system=self.monitoring_system,
                classification_engine=self.classification_engine
            )
            
            self.infrastructure_manager = TestingInfrastructure(
                environment_manager=self.environment_manager,
                audit_logger=self.audit_logger,
                monitoring_system=self.monitoring_system
            )
            
            self.isolation_framework = SecurityIsolationFramework(
                audit_logger=self.audit_logger,
                monitoring_system=self.monitoring_system,
                real_time_alerting=self.alerting_system
            )
            
            self.orchestrator = EnvironmentOrchestrator(
                environment_manager=self.environment_manager,
                infrastructure_manager=self.infrastructure_manager,
                isolation_framework=self.isolation_framework,
                audit_logger=self.audit_logger,
                monitoring_system=self.monitoring_system
            )
            
            # Start monitoring tasks
            asyncio.create_task(self._start_platform_monitoring())
            
            self.status = PlatformStatus.READY
            
            await self._log_platform_event(
                "platform_initialized",
                "Integrated Penetration Testing Platform successfully initialized"
            )
            
            logger.info("Platform initialization completed successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize platform: {e}")
            self.status = PlatformStatus.ERROR
            
            if self.alerting_system:
                await self.alerting_system.send_alert(
                    priority="CRITICAL",
                    message="Penetration Testing Platform initialization failed",
                    details=str(e)
                )

    # High-level API methods

    async def create_testing_session(self,
                                   session_name: str,
                                   scenario_id: str,
                                   security_level: SecurityLevel,
                                   authorized_by: str,
                                   created_by: str,
                                   duration_hours: Optional[int] = None,
                                   isolation_level: Optional[IsolationLevel] = None,
                                   custom_parameters: Optional[Dict[str, Any]] = None) -> str:
        """
        Create a new penetration testing session.
        
        Args:
            session_name: Name for the testing session
            scenario_id: Test scenario to execute
            security_level: Security classification level
            authorized_by: Authorization authority
            created_by: Session creator
            duration_hours: Session duration (uses default if not specified)
            isolation_level: Security isolation level
            custom_parameters: Custom session parameters
            
        Returns:
            Session ID
        """
        try:
            if self.status != PlatformStatus.READY:
                raise RuntimeError(f"Platform not ready: {self.status.value}")
            
            session_id = str(uuid4())
            session_start_time = datetime.now(timezone.utc)
            
            # Apply security classification if engine is available
            if self.classification_engine:
                await self._apply_session_classification(
                    session_id, security_level, authorized_by
                )
            
            # Create orchestration workflow
            workflow_id = await self.orchestrator.create_workflow(
                scenario_id=scenario_id,
                workflow_name=session_name,
                created_by=created_by,
                authorized_by=authorized_by,
                custom_parameters=custom_parameters
            )
            
            # Create session record
            session_info = {
                'session_id': session_id,
                'workflow_id': workflow_id,
                'name': session_name,
                'scenario_id': scenario_id,
                'security_level': security_level.value,
                'isolation_level': isolation_level.value if isolation_level else 'controlled_access',
                'authorized_by': authorized_by,
                'created_by': created_by,
                'created_at': session_start_time,
                'duration_hours': duration_hours or self.config.default_environment_duration_hours,
                'status': 'created',
                'environment_id': None,
                'infrastructure_deployments': [],
                'security_events': [],
                'custom_parameters': custom_parameters or {}
            }
            
            self.active_sessions[session_id] = session_info
            
            # Update metrics
            self.metrics.total_workflows_executed += 1
            
            # Log session creation
            await self._log_platform_event(
                "testing_session_created",
                f"Testing session '{session_name}' created by {created_by}",
                additional_data={
                    'session_id': session_id,
                    'workflow_id': workflow_id,
                    'scenario_id': scenario_id,
                    'security_level': security_level.value
                }
            )
            
            logger.info(f"Created testing session {session_id} with workflow {workflow_id}")
            
            return session_id
            
        except Exception as e:
            logger.error(f"Failed to create testing session: {e}")
            raise

    async def start_testing_session(self, session_id: str) -> bool:
        """
        Start a penetration testing session.
        
        Args:
            session_id: Session ID to start
            
        Returns:
            True if session started successfully
        """
        try:
            if session_id not in self.active_sessions:
                raise ValueError(f"Session {session_id} not found")
            
            session_info = self.active_sessions[session_id]
            workflow_id = session_info['workflow_id']
            
            # Start orchestration workflow
            success = await self.orchestrator.start_workflow(workflow_id)
            
            if success:
                session_info['status'] = 'running'
                session_info['started_at'] = datetime.now(timezone.utc)
                
                # Update metrics
                self.metrics.active_workflows += 1
                
                # Log session start
                await self._log_platform_event(
                    "testing_session_started",
                    f"Testing session '{session_info['name']}' started",
                    additional_data={'session_id': session_id, 'workflow_id': workflow_id}
                )
                
                logger.info(f"Started testing session {session_id}")
            else:
                session_info['status'] = 'failed'
                logger.error(f"Failed to start testing session {session_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to start testing session {session_id}: {e}")
            return False

    async def get_session_status(self, session_id: str) -> Dict[str, Any]:
        """
        Get comprehensive session status.
        
        Args:
            session_id: Session ID
            
        Returns:
            Session status information
        """
        try:
            if session_id not in self.active_sessions:
                raise ValueError(f"Session {session_id} not found")
            
            session_info = self.active_sessions[session_id]
            workflow_id = session_info['workflow_id']
            
            # Get workflow status
            workflow_status = await self.orchestrator.get_workflow_status(workflow_id)
            
            # Get environment status if available
            environment_status = {}
            if workflow_status.get('environment_id'):
                try:
                    environment_status = await self.environment_manager.get_environment_status(
                        workflow_status['environment_id']
                    )
                except Exception as e:
                    logger.warning(f"Failed to get environment status: {e}")
            
            # Get isolation status if available
            isolation_status = {}
            if workflow_status.get('environment_id') and self.isolation_framework:
                try:
                    isolation_status = await self.isolation_framework.get_isolation_status(
                        workflow_status['environment_id']
                    )
                except Exception as e:
                    logger.warning(f"Failed to get isolation status: {e}")
            
            # Compile comprehensive status
            status = {
                'session_id': session_id,
                'name': session_info['name'],
                'status': session_info['status'],
                'security_level': session_info['security_level'],
                'isolation_level': session_info['isolation_level'],
                'created_by': session_info['created_by'],
                'authorized_by': session_info['authorized_by'],
                'created_at': session_info['created_at'].isoformat(),
                'started_at': session_info.get('started_at', {}).isoformat() if session_info.get('started_at') else None,
                'duration_hours': session_info['duration_hours'],
                'workflow': workflow_status,
                'environment': environment_status,
                'isolation': isolation_status,
                'security_events': session_info['security_events'][-10:],  # Last 10 events
                'custom_parameters': session_info['custom_parameters']
            }
            
            return status
            
        except Exception as e:
            logger.error(f"Failed to get session status: {e}")
            return {'error': str(e)}

    async def stop_testing_session(self, session_id: str, reason: str = "Manual stop") -> bool:
        """
        Stop a running testing session.
        
        Args:
            session_id: Session ID to stop
            reason: Reason for stopping
            
        Returns:
            True if session stopped successfully
        """
        try:
            if session_id not in self.active_sessions:
                raise ValueError(f"Session {session_id} not found")
            
            session_info = self.active_sessions[session_id]
            workflow_id = session_info['workflow_id']
            
            # Cancel workflow
            success = await self.orchestrator.cancel_workflow(workflow_id)
            
            if success:
                session_info['status'] = 'stopped'
                session_info['stopped_at'] = datetime.now(timezone.utc)
                session_info['stop_reason'] = reason
                
                # Update metrics
                self.metrics.active_workflows = max(0, self.metrics.active_workflows - 1)
                
                # Log session stop
                await self._log_platform_event(
                    "testing_session_stopped",
                    f"Testing session '{session_info['name']}' stopped: {reason}",
                    additional_data={'session_id': session_id, 'workflow_id': workflow_id}
                )
                
                logger.info(f"Stopped testing session {session_id}: {reason}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to stop testing session {session_id}: {e}")
            return False

    async def list_active_sessions(self) -> List[Dict[str, Any]]:
        """
        List all active testing sessions.
        
        Returns:
            List of active session summaries
        """
        try:
            sessions = []
            
            for session_id, session_info in self.active_sessions.items():
                if session_info['status'] in ['created', 'running']:
                    # Calculate duration if started
                    duration_minutes = 0.0
                    if session_info.get('started_at'):
                        duration = datetime.now(timezone.utc) - session_info['started_at']
                        duration_minutes = duration.total_seconds() / 60
                    
                    session_summary = {
                        'session_id': session_id,
                        'name': session_info['name'],
                        'status': session_info['status'],
                        'scenario_id': session_info['scenario_id'],
                        'security_level': session_info['security_level'],
                        'created_by': session_info['created_by'],
                        'created_at': session_info['created_at'].isoformat(),
                        'duration_minutes': duration_minutes,
                        'security_events_count': len(session_info['security_events'])
                    }
                    
                    sessions.append(session_summary)
            
            # Sort by creation time (newest first)
            sessions.sort(key=lambda x: x['created_at'], reverse=True)
            
            return sessions
            
        except Exception as e:
            logger.error(f"Failed to list active sessions: {e}")
            return []

    async def get_platform_status(self) -> Dict[str, Any]:
        """
        Get comprehensive platform status.
        
        Returns:
            Platform status and metrics
        """
        try:
            # Update metrics
            await self._update_platform_metrics()
            
            # Get component statuses
            component_status = {
                'environment_manager': 'ready' if self.environment_manager else 'unavailable',
                'infrastructure_manager': 'ready' if self.infrastructure_manager else 'unavailable',
                'isolation_framework': 'ready' if self.isolation_framework else 'unavailable',
                'orchestrator': 'ready' if self.orchestrator else 'unavailable'
            }
            
            # Calculate uptime
            uptime = datetime.now(timezone.utc) - self.start_time
            self.metrics.uptime_hours = uptime.total_seconds() / 3600
            
            status = {
                'platform_status': self.status.value,
                'testing_mode': self.config.testing_mode.value,
                'uptime_hours': self.metrics.uptime_hours,
                'components': component_status,
                'metrics': {
                    'total_environments_created': self.metrics.total_environments_created,
                    'active_environments': self.metrics.active_environments,
                    'total_workflows_executed': self.metrics.total_workflows_executed,
                    'active_workflows': self.metrics.active_workflows,
                    'security_violations_detected': self.metrics.security_violations_detected,
                    'environments_quarantined': self.metrics.environments_quarantined,
                    'average_environment_duration_minutes': self.metrics.average_environment_duration_minutes,
                    'resource_utilization_percent': self.metrics.resource_utilization_percent
                },
                'configuration': {
                    'max_concurrent_environments': self.config.max_concurrent_environments,
                    'max_concurrent_workflows': self.config.max_concurrent_workflows,
                    'default_environment_duration_hours': self.config.default_environment_duration_hours,
                    'compliance_mode_enabled': self.config.compliance_mode_enabled,
                    'real_time_monitoring_enabled': self.config.real_time_monitoring_enabled
                },
                'active_sessions_count': len([
                    s for s in self.active_sessions.values() 
                    if s['status'] in ['created', 'running']
                ]),
                'last_updated': datetime.now(timezone.utc).isoformat()
            }
            
            return status
            
        except Exception as e:
            logger.error(f"Failed to get platform status: {e}")
            return {'error': str(e)}

    async def get_security_dashboard(self) -> Dict[str, Any]:
        """
        Get security-focused dashboard data.
        
        Returns:
            Security dashboard information
        """
        try:
            # Get recent security events
            recent_events = []
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=24)
            
            for event in self.security_events[-100:]:  # Last 100 events
                if datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00')) >= cutoff_time:
                    recent_events.append(event)
            
            # Get isolation violations across all sessions
            isolation_violations = []
            if self.isolation_framework:
                try:
                    violations = await self.isolation_framework.list_violations(hours=24)
                    isolation_violations = violations
                except Exception as e:
                    logger.warning(f"Failed to get isolation violations: {e}")
            
            # Categorize security events by severity
            event_severity_counts = defaultdict(int)
            for event in recent_events:
                severity = event.get('severity', 'info').lower()
                event_severity_counts[severity] += 1
            
            # Get active environment security status
            environment_security_status = []
            for session_id, session_info in self.active_sessions.items():
                if session_info['status'] == 'running':
                    workflow_status = await self.orchestrator.get_workflow_status(session_info['workflow_id'])
                    if workflow_status.get('environment_id'):
                        env_security = {
                            'session_id': session_id,
                            'environment_id': workflow_status['environment_id'],
                            'security_level': session_info['security_level'],
                            'isolation_level': session_info['isolation_level'],
                            'security_events_count': len(session_info['security_events']),
                            'status': session_info['status']
                        }
                        environment_security_status.append(env_security)
            
            dashboard = {
                'security_overview': {
                    'total_security_events_24h': len(recent_events),
                    'critical_events': event_severity_counts['critical'],
                    'high_events': event_severity_counts['high'],
                    'medium_events': event_severity_counts['medium'],
                    'low_events': event_severity_counts['low'],
                    'isolation_violations': len(isolation_violations),
                    'environments_quarantined': self.metrics.environments_quarantined
                },
                'recent_security_events': recent_events[-20:],  # Last 20 events
                'isolation_violations': isolation_violations,
                'active_environment_security': environment_security_status,
                'security_metrics': {
                    'average_security_events_per_session': (
                        sum(len(s['security_events']) for s in self.active_sessions.values()) /
                        max(1, len(self.active_sessions))
                    ),
                    'quarantine_rate_percent': (
                        self.metrics.environments_quarantined / 
                        max(1, self.metrics.total_environments_created)
                    ) * 100
                },
                'last_updated': datetime.now(timezone.utc).isoformat()
            }
            
            return dashboard
            
        except Exception as e:
            logger.error(f"Failed to get security dashboard: {e}")
            return {'error': str(e)}

    # Private methods

    async def _apply_session_classification(self, 
                                          session_id: str, 
                                          security_level: SecurityLevel, 
                                          authorized_by: str) -> None:
        """Apply security classification to session"""
        try:
            if not self.classification_engine:
                return
            
            classification_data = {
                'session_id': session_id,
                'security_level': security_level.value,
                'classification_markings': {
                    'banner': f"{security_level.value.upper()}//FOR OFFICIAL USE ONLY",
                    'portion_markings': True,
                    'dissemination_controls': []
                },
                'access_controls': {
                    'authorized_personnel': [authorized_by],
                    'clearance_required': security_level.value,
                    'need_to_know': True
                }
            }
            
            await self.classification_engine.apply_classification(
                resource_id=session_id,
                resource_type="testing_session",
                classification_data=classification_data
            )
            
        except Exception as e:
            logger.error(f"Failed to apply session classification: {e}")

    async def _start_platform_monitoring(self) -> None:
        """Start platform monitoring tasks"""
        try:
            async def monitoring_loop():
                while True:
                    try:
                        await self._monitor_platform_health()
                        await self._monitor_security_events()
                        await self._cleanup_expired_sessions()
                        await asyncio.sleep(self.config.resource_monitoring_interval)
                    except Exception as e:
                        logger.error(f"Error in platform monitoring: {e}")
                        await asyncio.sleep(self.config.resource_monitoring_interval)
            
            asyncio.create_task(monitoring_loop())
            
        except Exception as e:
            logger.error(f"Failed to start platform monitoring: {e}")

    async def _monitor_platform_health(self) -> None:
        """Monitor platform health and performance"""
        try:
            # Check component health
            if not all([self.environment_manager, self.infrastructure_manager, 
                       self.isolation_framework, self.orchestrator]):
                self.status = PlatformStatus.DEGRADED
                return
            
            # Check resource utilization
            if self.environment_manager:
                try:
                    resource_stats = await self.environment_manager.get_resource_usage()
                    if resource_stats.get('environments', {}).get('active_environments', 0) > 0:
                        # Calculate resource utilization
                        resources = resource_stats.get('resources', {})
                        cpu_usage = resources.get('total_cpu_cores', 0)
                        memory_usage = resources.get('total_memory_gb', 0)
                        
                        # Simple utilization calculation (would be more sophisticated in production)
                        max_cpu = 16  # Example maximum
                        max_memory = 64  # Example maximum
                        
                        cpu_percent = (cpu_usage / max_cpu) * 100 if max_cpu > 0 else 0
                        memory_percent = (memory_usage / max_memory) * 100 if max_memory > 0 else 0
                        
                        self.metrics.resource_utilization_percent = max(cpu_percent, memory_percent)
                except Exception as e:
                    logger.warning(f"Failed to get resource stats: {e}")
            
            # Update platform status based on health checks
            if self.metrics.resource_utilization_percent > 90:
                self.status = PlatformStatus.DEGRADED
            elif self.status == PlatformStatus.DEGRADED and self.metrics.resource_utilization_percent < 80:
                self.status = PlatformStatus.READY
                
        except Exception as e:
            logger.error(f"Failed to monitor platform health: {e}")

    async def _monitor_security_events(self) -> None:
        """Monitor for security events across all sessions"""
        try:
            # Check isolation framework for violations
            if self.isolation_framework:
                violations = await self.isolation_framework.list_violations(hours=1)
                
                for violation in violations:
                    # Create security event
                    security_event = {
                        'event_id': str(uuid4()),
                        'type': 'security_violation',
                        'severity': violation.get('severity', 'medium'),
                        'description': violation.get('description', 'Security violation detected'),
                        'environment_id': violation.get('environment_id'),
                        'timestamp': datetime.now(timezone.utc).isoformat(),
                        'source': 'isolation_framework',
                        'details': violation
                    }
                    
                    self.security_events.append(security_event)
                    self.metrics.security_violations_detected += 1
                    
                    # Add to relevant session
                    for session_info in self.active_sessions.values():
                        workflow_status = await self.orchestrator.get_workflow_status(
                            session_info['workflow_id']
                        )
                        if workflow_status.get('environment_id') == violation.get('environment_id'):
                            session_info['security_events'].append(security_event)
                            break
            
            # Limit security events history
            if len(self.security_events) > 10000:
                self.security_events = self.security_events[-5000:]  # Keep last 5000
                
        except Exception as e:
            logger.error(f"Failed to monitor security events: {e}")

    async def _cleanup_expired_sessions(self) -> None:
        """Cleanup expired testing sessions"""
        try:
            current_time = datetime.now(timezone.utc)
            sessions_to_cleanup = []
            
            for session_id, session_info in self.active_sessions.items():
                session_age = current_time - session_info['created_at']
                max_age = timedelta(hours=session_info['duration_hours'])
                
                if session_age > max_age and session_info['status'] in ['running', 'created']:
                    sessions_to_cleanup.append(session_id)
            
            for session_id in sessions_to_cleanup:
                try:
                    await self.stop_testing_session(session_id, "Session expired")
                    logger.info(f"Cleaned up expired session {session_id}")
                except Exception as e:
                    logger.error(f"Failed to cleanup session {session_id}: {e}")
                    
        except Exception as e:
            logger.error(f"Failed to cleanup expired sessions: {e}")

    async def _update_platform_metrics(self) -> None:
        """Update platform metrics"""
        try:
            # Count active environments and workflows
            active_envs = 0
            active_workflows = 0
            
            for session_info in self.active_sessions.values():
                if session_info['status'] == 'running':
                    active_workflows += 1
                    
                    # Check if environment is active
                    workflow_status = await self.orchestrator.get_workflow_status(
                        session_info['workflow_id']
                    )
                    if workflow_status.get('environment_id'):
                        active_envs += 1
            
            self.metrics.active_environments = active_envs
            self.metrics.active_workflows = active_workflows
            
            # Calculate average environment duration
            completed_sessions = [
                s for s in self.active_sessions.values() 
                if s['status'] == 'stopped' and s.get('started_at') and s.get('stopped_at')
            ]
            
            if completed_sessions:
                total_duration = sum(
                    (s['stopped_at'] - s['started_at']).total_seconds() / 60
                    for s in completed_sessions
                )
                self.metrics.average_environment_duration_minutes = total_duration / len(completed_sessions)
            
            self.metrics.last_updated = datetime.now(timezone.utc)
            
        except Exception as e:
            logger.error(f"Failed to update platform metrics: {e}")

    async def _log_platform_event(self, 
                                event_type: str, 
                                message: str, 
                                additional_data: Optional[Dict[str, Any]] = None) -> None:
        """Log platform events"""
        try:
            if not self.audit_logger:
                return
            
            event_data = {
                'event_type': event_type,
                'message': message,
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'component': 'integrated_pentest_platform'
            }
            
            if additional_data:
                event_data.update(additional_data)
            
            await self.audit_logger.log_event(
                event_type="PLATFORM_EVENT",
                severity="INFO",
                resource_type="penetration_testing_platform",
                resource_id="platform",
                action=event_type,
                additional_data=event_data
            )
            
        except Exception as e:
            logger.error(f"Failed to log platform event: {e}")


def create_integrated_pentest_platform(configuration: Optional[PlatformConfiguration] = None,
                                      existing_audit_logger: Optional[Any] = None,
                                      existing_monitoring_system: Optional[Any] = None,
                                      existing_classification_engine: Optional[Any] = None,
                                      existing_alerting_system: Optional[Any] = None):
    """
    Factory function to create an IntegratedPentestPlatform instance.
    
    Args:
        configuration: Platform configuration settings
        existing_audit_logger: Existing audit logging system
        existing_monitoring_system: Existing security monitoring system
        existing_classification_engine: Existing classification engine
        existing_alerting_system: Existing alerting system
        
    Returns:
        IntegratedPentestPlatform instance
    """
    return IntegratedPentestPlatform(
        configuration=configuration,
        existing_audit_logger=existing_audit_logger,
        existing_monitoring_system=existing_monitoring_system,
        existing_classification_engine=existing_classification_engine,
        existing_alerting_system=existing_alerting_system
    )


# Example usage
if __name__ == "__main__":
    async def example_usage():
        """Example usage of the integrated penetration testing platform"""
        
        # Create platform configuration
        config = PlatformConfiguration(
            testing_mode=TestingMode.TESTING,
            max_concurrent_environments=5,
            default_environment_duration_hours=4,
            compliance_mode_enabled=True
        )
        
        # Create platform
        platform = create_integrated_pentest_platform(configuration=config)
        
        # Wait for initialization
        await asyncio.sleep(5)
        
        # Get platform status
        status = await platform.get_platform_status()
        print(f"Platform status: {status['platform_status']}")
        
        # Create a testing session
        session_id = await platform.create_testing_session(
            session_name="Web Application Security Test",
            scenario_id="web_app_basic",
            security_level=SecurityLevel.CUI,
            authorized_by="security-team@company.com",
            created_by="pentester@company.com",
            duration_hours=4
        )
        
        print(f"Created session: {session_id}")
        
        # Start the session
        started = await platform.start_testing_session(session_id)
        print(f"Session started: {started}")
        
        # Monitor session progress
        for i in range(5):
            await asyncio.sleep(30)  # Wait 30 seconds
            session_status = await platform.get_session_status(session_id)
            print(f"Session status: {session_status.get('status', 'unknown')}")
            
            if session_status.get('workflow', {}).get('status') in ['completed', 'failed']:
                break
        
        # Get security dashboard
        security_dashboard = await platform.get_security_dashboard()
        print(f"Security events: {security_dashboard['security_overview']['total_security_events_24h']}")
        
        # List active sessions
        active_sessions = await platform.list_active_sessions()
        print(f"Active sessions: {len(active_sessions)}")
        
        # Stop the session
        stopped = await platform.stop_testing_session(session_id, "Example completed")
        print(f"Session stopped: {stopped}")
    
    # Run example
    asyncio.run(example_usage())