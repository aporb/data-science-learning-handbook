"""
Vulnerability Assessment Framework
Comprehensive vulnerability assessment with CVE integration, risk scoring, and prioritization.
"""

import requests
import json
import sqlite3
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
import logging
import re
from enum import Enum
import hashlib

logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high" 
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityStatus(Enum):
    NEW = "new"
    CONFIRMED = "confirmed"
    IN_PROGRESS = "in_progress"
    REMEDIATED = "remediated"
    ACCEPTED_RISK = "accepted_risk"
    FALSE_POSITIVE = "false_positive"

@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: SeverityLevel
    cvss_score: float
    cvss_vector: Optional[str]
    affected_assets: List[str]
    discovery_method: str
    discovery_date: datetime
    status: VulnerabilityStatus
    remediation_priority: int
    remediation_effort: str
    remediation_recommendations: List[str]
    compliance_mappings: Dict[str, List[str]]
    metadata: Dict[str, Any]

@dataclass
class Asset:
    """Asset information for vulnerability correlation"""
    id: str
    name: str
    type: str  # server, application, network_device, etc.
    ip_addresses: List[str]
    hostnames: List[str]
    operating_system: Optional[str]
    services: List[Dict[str, Any]]
    criticality: str  # critical, high, medium, low
    classification: str  # NIPR, SIPR, JWICS
    owner: str
    location: str
    last_scanned: datetime

class VulnerabilityAssessor:
    """Comprehensive vulnerability assessment and management system"""
    
    def __init__(self, db_path: str = "vulnerability_db.sqlite"):
        self.db_path = Path(db_path)
        self.nist_api_base = "https://services.nvd.nist.gov/rest/json"
        self.initialize_database()
        
        # CVSS scoring weights for DoD environment
        self.scoring_weights = {
            'exploitability': 1.2,  # Higher weight for DoD
            'impact': 1.0,
            'temporal': 0.9,
            'environmental': 1.1
        }
        
        # DoD STIG compliance mappings
        self.stig_mappings = self._load_stig_mappings()
        
    def initialize_database(self):
        """Initialize SQLite database for vulnerability tracking"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id TEXT PRIMARY KEY,
                    cve_id TEXT,
                    title TEXT NOT NULL,
                    description TEXT,
                    severity TEXT NOT NULL,
                    cvss_score REAL,
                    cvss_vector TEXT,
                    affected_assets TEXT,  -- JSON array
                    discovery_method TEXT,
                    discovery_date TEXT,
                    status TEXT,
                    remediation_priority INTEGER,
                    remediation_effort TEXT,
                    remediation_recommendations TEXT,  -- JSON array
                    compliance_mappings TEXT,  -- JSON object
                    metadata TEXT,  -- JSON object
                    created_at TEXT,
                    updated_at TEXT
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS assets (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    type TEXT,
                    ip_addresses TEXT,  -- JSON array
                    hostnames TEXT,  -- JSON array
                    operating_system TEXT,
                    services TEXT,  -- JSON array
                    criticality TEXT,
                    classification TEXT,
                    owner TEXT,
                    location TEXT,
                    last_scanned TEXT,
                    created_at TEXT,
                    updated_at TEXT
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS cve_cache (
                    cve_id TEXT PRIMARY KEY,
                    cvss_score REAL,
                    cvss_vector TEXT,
                    description TEXT,
                    published_date TEXT,
                    last_modified TEXT,
                    cached_at TEXT
                )
            """)
            
            # Create indexes for performance
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vuln_severity ON vulnerabilities(severity)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vuln_status ON vulnerabilities(status)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vuln_cve ON vulnerabilities(cve_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_asset_classification ON assets(classification)")
    
    def _load_stig_mappings(self) -> Dict[str, Dict[str, List[str]]]:
        """Load STIG compliance mappings"""
        return {
            "Application_Security": {
                "APSC-DV-001330": ["SQL Injection", "Command Injection"],
                "APSC-DV-001340": ["Cross-Site Scripting", "XSS"],
                "APSC-DV-001350": ["Authentication Bypass", "Session Management"],
                "APSC-DV-001360": ["Privilege Escalation", "Authorization"],
                "APSC-DV-001370": ["Cryptographic Failures", "Weak Encryption"]
            },
            "Operating_System": {
                "RHEL-07-010010": ["Password Policy", "Account Management"],
                "RHEL-07-020010": ["Access Control", "File Permissions"],
                "RHEL-07-030010": ["Audit Logging", "Security Monitoring"],
                "RHEL-07-040010": ["Network Security", "Firewall Configuration"]
            },
            "Network": {
                "NET-INFR-001": ["Network Segmentation", "VLAN Security"],
                "NET-INFR-002": ["Encryption in Transit", "TLS Configuration"],
                "NET-INFR-003": ["Network Access Control", "Port Security"]
            }
        }
    
    def assess_vulnerability(self, scan_finding: Dict[str, Any], asset_info: Optional[Asset] = None) -> Vulnerability:
        """Assess and enrich vulnerability from scan finding"""
        
        # Generate unique vulnerability ID
        vuln_content = f"{scan_finding.get('title', '')}{scan_finding.get('description', '')}"
        vuln_id = hashlib.sha256(vuln_content.encode()).hexdigest()[:16]
        
        # Extract or assign CVE ID
        cve_id = self._extract_cve_id(scan_finding)
        
        # Get CVE details if available
        cvss_score = 0.0
        cvss_vector = None
        if cve_id:
            cve_details = self._get_cve_details(cve_id)
            if cve_details:
                cvss_score = cve_details.get('cvss_score', 0.0)
                cvss_vector = cve_details.get('cvss_vector')
        
        # Determine severity
        severity = self._calculate_severity(scan_finding, cvss_score, asset_info)
        
        # Calculate remediation priority
        priority = self._calculate_remediation_priority(severity, asset_info, cvss_score)
        
        # Generate remediation recommendations
        recommendations = self._generate_recommendations(scan_finding, cve_id, asset_info)
        
        # Map to compliance frameworks
        compliance_mappings = self._map_to_compliance(scan_finding)
        
        vulnerability = Vulnerability(
            id=vuln_id,
            cve_id=cve_id,
            title=scan_finding.get('title', 'Unknown Vulnerability'),
            description=scan_finding.get('description', ''),
            severity=severity,
            cvss_score=cvss_score,
            cvss_vector=cvss_vector,
            affected_assets=[asset_info.id] if asset_info else [],
            discovery_method=scan_finding.get('scanner', 'manual'),
            discovery_date=datetime.now(timezone.utc),
            status=VulnerabilityStatus.NEW,
            remediation_priority=priority,
            remediation_effort=self._estimate_effort(severity, scan_finding),
            remediation_recommendations=recommendations,
            compliance_mappings=compliance_mappings,
            metadata=scan_finding
        )
        
        self._save_vulnerability(vulnerability)
        return vulnerability
    
    def _extract_cve_id(self, finding: Dict[str, Any]) -> Optional[str]:
        """Extract CVE ID from finding"""
        text = f"{finding.get('title', '')} {finding.get('description', '')}"
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        match = re.search(cve_pattern, text, re.IGNORECASE)
        return match.group(0).upper() if match else None
    
    def _get_cve_details(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Get CVE details from NIST NVD or cache"""
        
        # Check cache first
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT cvss_score, cvss_vector, description FROM cve_cache WHERE cve_id = ?",
                (cve_id,)
            )
            cached = cursor.fetchone()
            if cached:
                return {
                    'cvss_score': cached[0],
                    'cvss_vector': cached[1],
                    'description': cached[2]
                }
        
        # Fetch from NIST NVD
        try:
            url = f"{self.nist_api_base}/cves/2.0"
            params = {'cveId': cve_id}
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if data.get('vulnerabilities'):
                vuln_data = data['vulnerabilities'][0]['cve']
                
                # Extract CVSS score
                cvss_score = 0.0
                cvss_vector = None
                
                metrics = vuln_data.get('metrics', {})
                if 'cvssMetricV31' in metrics:
                    cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    cvss_vector = cvss_data.get('vectorString')
                elif 'cvssMetricV30' in metrics:
                    cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    cvss_vector = cvss_data.get('vectorString')
                elif 'cvssMetricV2' in metrics:
                    cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    cvss_vector = cvss_data.get('vectorString')
                
                description = vuln_data.get('descriptions', [{}])[0].get('value', '')
                
                # Cache the result
                with sqlite3.connect(self.db_path) as conn:
                    conn.execute("""
                        INSERT OR REPLACE INTO cve_cache 
                        (cve_id, cvss_score, cvss_vector, description, cached_at)
                        VALUES (?, ?, ?, ?, ?)
                    """, (cve_id, cvss_score, cvss_vector, description, datetime.now(timezone.utc).isoformat()))
                
                return {
                    'cvss_score': cvss_score,
                    'cvss_vector': cvss_vector,
                    'description': description
                }
                
        except Exception as e:
            logger.error(f"Failed to fetch CVE details for {cve_id}: {e}")
        
        return None
    
    def _calculate_severity(self, finding: Dict[str, Any], cvss_score: float, asset: Optional[Asset]) -> SeverityLevel:
        """Calculate vulnerability severity using multiple factors"""
        
        # Base severity from CVSS score
        if cvss_score >= 9.0:
            base_severity = SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            base_severity = SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            base_severity = SeverityLevel.MEDIUM
        elif cvss_score > 0.0:
            base_severity = SeverityLevel.LOW
        else:
            # Fallback to scanner severity
            scanner_severity = finding.get('severity', 'low').lower()
            severity_map = {
                'critical': SeverityLevel.CRITICAL,
                'high': SeverityLevel.HIGH,
                'medium': SeverityLevel.MEDIUM,
                'low': SeverityLevel.LOW,
                'info': SeverityLevel.INFO
            }
            base_severity = severity_map.get(scanner_severity, SeverityLevel.LOW)
        
        # Adjust based on asset criticality and classification
        if asset:
            if asset.classification in ['SIPR', 'JWICS']:
                # Escalate severity for classified systems
                if base_severity == SeverityLevel.MEDIUM:
                    base_severity = SeverityLevel.HIGH
                elif base_severity == SeverityLevel.HIGH:
                    base_severity = SeverityLevel.CRITICAL
            
            if asset.criticality == 'critical':
                # Escalate for critical assets
                if base_severity == SeverityLevel.LOW:
                    base_severity = SeverityLevel.MEDIUM
                elif base_severity == SeverityLevel.MEDIUM:
                    base_severity = SeverityLevel.HIGH
        
        return base_severity
    
    def _calculate_remediation_priority(self, severity: SeverityLevel, asset: Optional[Asset], cvss_score: float) -> int:
        """Calculate remediation priority (1-100, higher = more urgent)"""
        
        # Base priority from severity
        severity_priority = {
            SeverityLevel.CRITICAL: 90,
            SeverityLevel.HIGH: 70,
            SeverityLevel.MEDIUM: 50,
            SeverityLevel.LOW: 30,
            SeverityLevel.INFO: 10
        }
        
        priority = severity_priority[severity]
        
        # Adjust for asset factors
        if asset:
            # Classification multiplier
            classification_multiplier = {
                'JWICS': 1.3,
                'SIPR': 1.2,
                'NIPR': 1.0
            }
            priority *= classification_multiplier.get(asset.classification, 1.0)
            
            # Criticality adjustment
            criticality_adjustment = {
                'critical': 20,
                'high': 10,
                'medium': 0,
                'low': -10
            }
            priority += criticality_adjustment.get(asset.criticality, 0)
        
        # CVSS score fine-tuning
        if cvss_score > 0:
            priority += (cvss_score - 5.0) * 2  # Adjust +/- based on CVSS
        
        return max(1, min(100, int(priority)))
    
    def _generate_recommendations(self, finding: Dict[str, Any], cve_id: Optional[str], asset: Optional[Asset]) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []
        
        # Generic recommendations based on vulnerability type
        title_desc = f"{finding.get('title', '')} {finding.get('description', '')}".lower()
        
        if any(keyword in title_desc for keyword in ['sql injection', 'sqli']):
            recommendations.extend([
                "Implement parameterized queries or prepared statements",
                "Input validation and sanitization",
                "Principle of least privilege for database access",
                "Web Application Firewall (WAF) deployment"
            ])
        
        elif any(keyword in title_desc for keyword in ['cross-site scripting', 'xss']):
            recommendations.extend([
                "Output encoding and escaping",
                "Content Security Policy (CSP) implementation",
                "Input validation and sanitization",
                "Use security-focused frameworks"
            ])
        
        elif any(keyword in title_desc for keyword in ['authentication', 'auth bypass']):
            recommendations.extend([
                "Implement multi-factor authentication (MFA)",
                "Review session management controls",
                "Enforce strong password policies",
                "Regular access control reviews"
            ])
        
        elif any(keyword in title_desc for keyword in ['encryption', 'crypto', 'ssl', 'tls']):
            recommendations.extend([
                "Update to TLS 1.3 or latest version",
                "Use strong cipher suites",
                "Implement HSTS headers",
                "Regular certificate management"
            ])
        
        elif any(keyword in title_desc for keyword in ['patch', 'update', 'version']):
            recommendations.extend([
                "Apply latest security patches",
                "Implement automated patch management",
                "Regular vulnerability scanning",
                "Maintain software inventory"
            ])
        
        # Asset-specific recommendations
        if asset:
            if asset.type == 'web_application':
                recommendations.append("Conduct regular web application security testing")
            elif asset.type == 'database':
                recommendations.append("Implement database activity monitoring")
            elif asset.classification in ['SIPR', 'JWICS']:
                recommendations.append("Follow DoD STIG requirements for classified systems")
        
        # CVE-specific recommendations
        if cve_id:
            recommendations.append(f"Review NIST guidance for {cve_id}")
            recommendations.append(f"Check vendor advisories for {cve_id}")
        
        return list(set(recommendations))  # Remove duplicates
    
    def _map_to_compliance(self, finding: Dict[str, Any]) -> Dict[str, List[str]]:
        """Map vulnerability to compliance frameworks"""
        mappings = {}
        
        title_desc = f"{finding.get('title', '')} {finding.get('description', '')}".lower()
        
        # NIST 800-53 mappings
        nist_controls = []
        if any(keyword in title_desc for keyword in ['authentication', 'auth']):
            nist_controls.extend(['AC-2', 'AC-3', 'IA-2', 'IA-5'])
        if any(keyword in title_desc for keyword in ['encryption', 'crypto']):
            nist_controls.extend(['SC-8', 'SC-13', 'SC-28'])
        if any(keyword in title_desc for keyword in ['audit', 'logging']):
            nist_controls.extend(['AU-2', 'AU-3', 'AU-12'])
        
        if nist_controls:
            mappings['NIST_800_53'] = nist_controls
        
        # STIG mappings
        stig_controls = []
        for category, controls in self.stig_mappings.items():
            for control_id, keywords in controls.items():
                if any(keyword.lower() in title_desc for keyword in keywords):
                    stig_controls.append(control_id)
        
        if stig_controls:
            mappings['DoD_STIG'] = stig_controls
        
        # CIS Controls
        cis_controls = []
        if any(keyword in title_desc for keyword in ['inventory', 'asset']):
            cis_controls.append('CIS-1')
        if any(keyword in title_desc for keyword in ['patch', 'update']):
            cis_controls.append('CIS-3')
        if any(keyword in title_desc for keyword in ['access', 'privilege']):
            cis_controls.extend(['CIS-5', 'CIS-6'])
        
        if cis_controls:
            mappings['CIS_Controls'] = cis_controls
        
        return mappings
    
    def _estimate_effort(self, severity: SeverityLevel, finding: Dict[str, Any]) -> str:
        """Estimate remediation effort"""
        
        title_desc = f"{finding.get('title', '')} {finding.get('description', '')}".lower()
        
        # High effort indicators
        if any(keyword in title_desc for keyword in ['architecture', 'design', 'framework']):
            return 'High (weeks-months)'
        
        # Medium effort indicators
        if any(keyword in title_desc for keyword in ['configuration', 'policy', 'procedure']):
            return 'Medium (days-weeks)'
        
        # Low effort indicators  
        if any(keyword in title_desc for keyword in ['patch', 'update', 'setting']):
            return 'Low (hours-days)'
        
        # Default based on severity
        effort_map = {
            SeverityLevel.CRITICAL: 'High (weeks-months)',
            SeverityLevel.HIGH: 'Medium (days-weeks)',
            SeverityLevel.MEDIUM: 'Medium (days-weeks)',
            SeverityLevel.LOW: 'Low (hours-days)',
            SeverityLevel.INFO: 'Low (hours-days)'
        }
        
        return effort_map[severity]
    
    def _save_vulnerability(self, vulnerability: Vulnerability):
        """Save vulnerability to database"""
        with sqlite3.connect(self.db_path) as conn:
            now = datetime.now(timezone.utc).isoformat()
            
            conn.execute("""
                INSERT OR REPLACE INTO vulnerabilities (
                    id, cve_id, title, description, severity, cvss_score, cvss_vector,
                    affected_assets, discovery_method, discovery_date, status,
                    remediation_priority, remediation_effort, remediation_recommendations,
                    compliance_mappings, metadata, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                vulnerability.id,
                vulnerability.cve_id,
                vulnerability.title,
                vulnerability.description,
                vulnerability.severity.value,
                vulnerability.cvss_score,
                vulnerability.cvss_vector,
                json.dumps(vulnerability.affected_assets),
                vulnerability.discovery_method,
                vulnerability.discovery_date.isoformat(),
                vulnerability.status.value,
                vulnerability.remediation_priority,
                vulnerability.remediation_effort,
                json.dumps(vulnerability.remediation_recommendations),
                json.dumps(vulnerability.compliance_mappings),
                json.dumps(vulnerability.metadata),
                now,
                now
            ))
    
    def get_vulnerabilities_by_priority(self, limit: int = 50) -> List[Vulnerability]:
        """Get vulnerabilities ordered by remediation priority"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT * FROM vulnerabilities 
                WHERE status NOT IN ('remediated', 'false_positive')
                ORDER BY remediation_priority DESC, cvss_score DESC 
                LIMIT ?
            """, (limit,))
            
            return [self._row_to_vulnerability(row) for row in cursor.fetchall()]
    
    def get_vulnerabilities_by_asset(self, asset_id: str) -> List[Vulnerability]:
        """Get all vulnerabilities affecting a specific asset"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT * FROM vulnerabilities 
                WHERE affected_assets LIKE ?
                ORDER BY remediation_priority DESC
            """, (f'%{asset_id}%',))
            
            return [self._row_to_vulnerability(row) for row in cursor.fetchall()]
    
    def get_compliance_gaps(self, framework: str = 'NIST_800_53') -> Dict[str, List[Vulnerability]]:
        """Get vulnerability gaps mapped to compliance controls"""
        gaps = {}
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT * FROM vulnerabilities 
                WHERE status NOT IN ('remediated', 'false_positive')
                AND compliance_mappings LIKE ?
            """, (f'%{framework}%',))
            
            for row in cursor.fetchall():
                vuln = self._row_to_vulnerability(row)
                mappings = vuln.compliance_mappings.get(framework, [])
                
                for control in mappings:
                    if control not in gaps:
                        gaps[control] = []
                    gaps[control].append(vuln)
        
        return gaps
    
    def _row_to_vulnerability(self, row: tuple) -> Vulnerability:
        """Convert database row to Vulnerability object"""
        return Vulnerability(
            id=row[0],
            cve_id=row[1],
            title=row[2],
            description=row[3],
            severity=SeverityLevel(row[4]),
            cvss_score=row[5],
            cvss_vector=row[6],
            affected_assets=json.loads(row[7]) if row[7] else [],
            discovery_method=row[8],
            discovery_date=datetime.fromisoformat(row[9]),
            status=VulnerabilityStatus(row[10]),
            remediation_priority=row[11],
            remediation_effort=row[12],
            remediation_recommendations=json.loads(row[13]) if row[13] else [],
            compliance_mappings=json.loads(row[14]) if row[14] else {},
            metadata=json.loads(row[15]) if row[15] else {}
        )
    
    def generate_assessment_report(self, output_path: str = "vulnerability_assessment_report.json") -> Dict[str, Any]:
        """Generate comprehensive vulnerability assessment report"""
        
        with sqlite3.connect(self.db_path) as conn:
            # Get vulnerability statistics
            cursor = conn.execute("""
                SELECT severity, COUNT(*) as count 
                FROM vulnerabilities 
                WHERE status NOT IN ('remediated', 'false_positive')
                GROUP BY severity
            """)
            severity_stats = dict(cursor.fetchall())
            
            # Get top vulnerabilities by priority
            top_vulns = self.get_vulnerabilities_by_priority(20)
            
            # Get compliance gaps
            nist_gaps = self.get_compliance_gaps('NIST_800_53')
            stig_gaps = self.get_compliance_gaps('DoD_STIG')
            
            report = {
                'report_metadata': {
                    'generated_at': datetime.now(timezone.utc).isoformat(),
                    'total_vulnerabilities': sum(severity_stats.values()),
                    'severity_breakdown': severity_stats
                },
                'top_vulnerabilities': [asdict(vuln) for vuln in top_vulns],
                'compliance_gaps': {
                    'NIST_800_53': {control: len(vulns) for control, vulns in nist_gaps.items()},
                    'DoD_STIG': {control: len(vulns) for control, vulns in stig_gaps.items()}
                },
                'risk_summary': self._calculate_risk_summary()
            }
            
            # Save report
            with open(output_path, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            
            logger.info(f"Vulnerability assessment report saved to: {output_path}")
            return report
    
    def _calculate_risk_summary(self) -> Dict[str, Any]:
        """Calculate overall risk summary metrics"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT 
                    AVG(CASE WHEN severity = 'critical' THEN 10
                             WHEN severity = 'high' THEN 7
                             WHEN severity = 'medium' THEN 4
                             WHEN severity = 'low' THEN 2
                             ELSE 1 END) as avg_risk_score,
                    COUNT(*) as total_count,
                    SUM(CASE WHEN status = 'new' THEN 1 ELSE 0 END) as new_count,
                    SUM(CASE WHEN remediation_priority >= 80 THEN 1 ELSE 0 END) as critical_priority_count
                FROM vulnerabilities 
                WHERE status NOT IN ('remediated', 'false_positive')
            """)
            
            row = cursor.fetchone()
            if row:
                return {
                    'average_risk_score': round(row[0] or 0, 2),
                    'total_open_vulnerabilities': row[1] or 0,
                    'new_vulnerabilities': row[2] or 0,
                    'critical_priority_vulnerabilities': row[3] or 0,
                    'risk_level': self._determine_risk_level(row[0] or 0, row[1] or 0)
                }
            else:
                return {
                    'average_risk_score': 0,
                    'total_open_vulnerabilities': 0,
                    'new_vulnerabilities': 0,
                    'critical_priority_vulnerabilities': 0,
                    'risk_level': 'Low'
                }
    
    def _determine_risk_level(self, avg_score: float, total_vulns: int) -> str:
        """Determine overall organizational risk level"""
        if avg_score >= 7 or total_vulns >= 100:
            return 'Critical'
        elif avg_score >= 5 or total_vulns >= 50:
            return 'High'
        elif avg_score >= 3 or total_vulns >= 20:
            return 'Medium'
        else:
            return 'Low'